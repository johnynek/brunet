/*
Copyright (C) 2008  David Wolinsky <davidiw@ufl.edu>, University of Florida

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace Brunet.Applications {
  /// <summary>The class configuration for BasicNode.  brunet1/config/ has some
  /// sample xml versions.</summary>
  /// <remarks>Below is a complete generic NodeConfig:
  /// <code>
  /// <NodeConfig>
  ///   <BrunetNamespace>GenericRealm</BrunetNamespace>
  ///     <RemoteTAs>
  ///       <Transport>brunet.udp://71.122.33.252:12342</Transport>
  ///       <Transport>brunet.udp://64.92.171.16:45322</Transport>
  ///     <RemoteTAs>
  ///   <EdgeListeners>
  ///     <EdgeListener type="udp"/>
  ///     <EdgeListener type="tcp">
  ///       <port>12333</port>
  ///     </EdgeListener>
  ///   </EdgeListeners>
  ///   <DevicesToBind>
  ///     <Device>eth0</Device>
  ///     <Device>Local Area Network 1</Device>
  ///   </DevicesToBind>
  ///   <XmlRpcManager>
  ///     <Enabled>true</Enabled>
  ///     <Port>23322</Port>
  ///   </XmlRpcManager>
  ///   <PrivateNodeConfig>
  ///     ...
  ///   </PrivateNodeConfig>
  /// </NodeConfig>
  /// </code>
  /// </remarks>

  public class PrivateNodeConfig {
    public PrivateNodeConfig() {
      Security = new NodeConfig.SecurityPolicy();
      BrunetNamespace = String.Empty;
    }

    public String BrunetNamespace;
    public NodeConfig.SecurityPolicy Security;
  }

  public class NodeConfig {
    public NodeConfig() {
      EdgeListeners = new EdgeListener[0];
      RemoteTAs = new String[0];
      DevicesToBind = new String[0];
      XmlRpcManager = new Service();
      NCService = new NCServiceConfig();
      Security = new SecurityPolicy();
      PrivateNodeConfig = new PrivateNodeConfig();
      BrunetNamespace = String.Empty;
      XmppServices = new XmppConfig();
    }

    /// <summary>Create a new node config given a public node config and a
    /// private node config, used to generate the private node.</summary>
    public static NodeConfig GetPrivateNodeConfig(NodeConfig nc)
    {
      NodeConfig private_config = Utils.Copy<NodeConfig>(nc);
      private_config.PrivateNodeConfig = null;
      private_config.BrunetNamespace = nc.PrivateNodeConfig.BrunetNamespace;
      private_config.Security = nc.PrivateNodeConfig.Security;
      private_config.RemoteTAs = new String[0];
      return private_config;
    }

    /**  <summary>This is equivalent to Node.Realm, only Nodes in the same
    realm can communicate with each other.  Required.</summary>*/
    public String BrunetNamespace;
    /**  <summary>A list of well known remote end points in the form of
    brunet.(udp,tcp)://ip_address:port.  This is optional if you wish to use
    the discovery feature of Brunet, that requires all nodes are on the same
    Layer 2 network.</summary>*/
    [XmlArrayItem (typeof(String), ElementName = "Transport")]
    public String[] RemoteTAs;
    /**  <summary>A list of local end points.  At least one local end point is
    required.</summary>*/
    public EdgeListener[] EdgeListeners;
    /**  <summary>A stored Node.Address for later re-use. This will be
    generated by the application and should never be manually entered.
    </summary>*/
    public String NodeAddress;
    /**  <summary>A list of network devices to advertise as end points on
    this machine.  This is optional but allows quicker connectivity, because
    it reduces the amount of end points peers advertise to each other.
    </summary>*/
    [XmlArrayItem (typeof(String), ElementName = "Device")]
    public String[] DevicesToBind;
    public NCServiceConfig NCService;
    public PrivateNodeConfig PrivateNodeConfig;
    /**  <summary>Specifies XmlRpc configuration.  This is optional and only
    required if XmlRpc is desired.</summary>*/
    public Service XmlRpcManager;
    public SecurityPolicy Security;
    public XmppConfig XmppServices;

    public class SecurityPolicy {
      public SecurityPolicy() {
        KeyPath = "private_key";
        CertificatePath = "certificates";
      }

      public bool Enabled;
      public bool SecureEdges;
      public bool TestEnable;
      [XmlIgnoreAttribute]
      public bool SecureEdgesEnabled { get { return Enabled && SecureEdges; } }
      /// <summary>In this mode, we allow preshared self-signed certificates.
      /// If we were to not have this mode, we could potentially be passing
      /// around very large messages listing all the CAs we support, when all
      /// CAs only support themselves! </summary>
      public bool SelfSignedCertificates;
      public string KeyPath;
      public string CertificatePath;
    }

    /**
    <summary>Used by services to specify if they are enabled and their port.
    </summary>
    */
    public class Service {
      /// <summary>Enabled the service</summary>
      public bool Enabled;
      /// <summary>Specifies the port where the service is running</summary>
      public int Port;
    }

    /// <summary>Enables for NCService</summary>
    public class NCServiceConfig {
      /// <summary>Enable NCService</summary>
      public bool Enabled;
      /// <summary>Allow NCService to optimize shortcuts</summary>
      public bool OptimizeShortcuts;
      /// <summary>Use checkpointing for NCService</summary>
      public bool Checkpointing;
      /// <summary>The checkpoint for ncservice</summary>
      public string Checkpoint;
    }

    /**
    <summary>Used to specify local end points by type (udp, tcp) and
    optionally a port.</summary>
    */
    public class EdgeListener {
      /// <summary>The type of EdgeListener, such as udp or tcp</summary>
      [XmlAttribute]
      public String type;
      /// <summary>A specific port number, 0 or missing for random</summary>
      public int port;
    }

    /// <summary>Used to configure XmppServices.</summary>
    public class XmppConfig {
      public bool Enabled;
      public string Username;
      public string Password;
      public string Server;
      public int Port;
    }

    /// <summary>Path to the configs file system location.</summary>
    [XmlIgnoreAttribute]
    public string Path;

    /// <summary>Writres the config to the file system.</summary>
    public bool WriteConfig() {
      if(Path == string.Empty || Path == null) {
        return false;
      }

      using(FileStream fs = new FileStream(Path, FileMode.Create, FileAccess.Write)) {
        XmlSerializer serializer = new XmlSerializer(this.GetType());
        serializer.Serialize(fs, this);
      }
      return true;
    }

    /// <summary>Read a NodeConfig, if it fails, then let's find the problem.</summary>
    public static NodeConfig ReadConfig(string path)
    {
      if(!File.Exists(path)) {
        throw new Exception("Missing NodeConfig.");
      }

      NodeConfig node_config = null;
      try {
        node_config = Utils.ReadConfig<NodeConfig>(path);
        node_config.Path = path;
      } catch {
        ConfigurationValidator cv = new ConfigurationValidator();
        cv.Validate(path, "Node.xsd");
      }
      return node_config;
    }
  }
}
